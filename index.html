// === CONFIGURACIÓN ===
const SPREADSHEET_ID = '1LwK8W7-Cdkqjs9cptFRZ_8zRi7-ucg7mb2x9RZvmttA';

// === ACCESO A LAS HOJAS ===
let clientesSheet, configSheet, mensajesSheet, transaccionesSheet;
try {
    const allSheets = SpreadsheetApp.openById(SPREADSHEET_ID).getSheets();
    clientesSheet = allSheets[0]; 
    configSheet = allSheets[1];   
    mensajesSheet = allSheets[2]; 
    transaccionesSheet = allSheets[3];
} catch (e) {
    throw new Error(`No se pudo abrir la hoja de cálculo. Verifica que el ID sea correcto y que el script tenga permisos. Error: ${e.message}`);
}

// === MANEJO DE PETICIONES (ROUTING) ===
function doGet(e) {
  try {
    const action = e.parameter.action;
    switch (action) {
      case 'listarTarjetas': return handleResponse(listarTarjetas());
      case 'obtenerConfiguracion': return handleResponse(obtenerConfiguracion());
      case 'obtenerMensajes': return handleResponse(obtenerMensajes());
      case 'buscarClientePorCredenciales': 
        return handleResponse(buscarClientePorCredenciales(e.parameter.telefono, e.parameter.fechaNacimiento));
      default:
        return handleResponse({ status: 'error', message: 'Acción GET no válida.' });
    }
  } catch (error) {
    Logger.log(`Error en doGet: ${error.toString()}`);
    return handleResponse({ status: 'error', message: `Error fatal en el servidor (doGet): ${error.message}`});
  }
}

function doPost(e) {
  try {
    const request = JSON.parse(e.postData.contents);
    const action = request.action;
    switch (action) {
      case 'buscarOcrearTarjeta': return handleResponse(buscarOcrearTarjeta(request.nombre, request.telefono, request.fechaNacimiento));
      case 'registrarVisita': return handleResponse(registrarVisita(request.folio));
      case 'canjearRecompensa': return handleResponse(canjearRecompensa(request.folio, request.nombreCliente, request.recompensa, request.costo));
      case 'guardarConfiguracion': return handleResponse(guardarConfiguracion(request.config));
      case 'enviarMensaje': return handleResponse(enviarMensaje(request.remitente, request.mensaje));
      case 'verificarAccesoMaestro': return handleResponse(verificarAccesoMaestro(request.usuario, request.passwordHash));
      default: return handleResponse({ status: 'error', message: 'Acción POST no válida.' });
    }
  } catch (error) {
    Logger.log(`Error en doPost: ${error.toString()}`);
    return handleResponse({ status: 'error', message: `Error fatal en el servidor (doPost): ${error.message}`});
  }
}

function handleResponse(data) {
  return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON);
}

// === LÓGICA DE SEGURIDAD ===
function verificarAccesoMaestro(usuario, passwordHash) {
  try {
    if (usuario.toLowerCase() !== 'admin') {
      return { status: 'error', message: 'Usuario incorrecto.' };
    }
    let values = [];
    if (configSheet.getLastRow() > 1) {
        values = configSheet.getRange("A2:C" + configSheet.getLastRow()).getValues();
    }
    let adminPasswordHash = null;
    let hashRowIndex = -1; 
    for (let i = 0; i < values.length; i++) {
      if (values[i][0] === 'Credencial' && values[i][1] === 'AdminPasswordHash') {
        adminPasswordHash = values[i][2];
        hashRowIndex = i + 2;
        break;
      }
    }
    if (!adminPasswordHash || String(adminPasswordHash).trim() === '') {
      if (hashRowIndex !== -1) {
        configSheet.getRange(hashRowIndex, 3).setValue(passwordHash);
      } else {
        configSheet.appendRow(['Credencial', 'AdminPasswordHash', passwordHash]);
      }
      return { status: 'success', message: '¡Contraseña configurada! Acceso concedido.' };
    }
    if (adminPasswordHash === passwordHash) {
      return { status: 'success', message: 'Acceso concedido.' };
    } else {
      return { status: 'error', message: 'Contraseña incorrecta.' };
    }
  } catch (e) {
    Logger.log("Error en verificarAccesoMaestro: " + e.toString());
    return { status: 'error', message: 'Error de servidor al verificar la contraseña: ' + e.message };
  }
}

// === LÓGICA DE CLIENTES Y OTRAS ===
function buscarClientePorCredenciales(telefono, fechaNacimiento) { const data = clientesSheet.getDataRange().getValues(); for (let i = 1; i < data.length; i++) { const sheetDate = data[i][4] ? new Date(data[i][4]).toISOString().split('T')[0] : ''; if (String(data[i][3]) == String(telefono) && sheetDate == String(fechaNacimiento)) { return { status: 'success', data: { folio: data[i][0], nombre: data[i][1], visitas: data[i][2] } }; } } return { status: 'error', message: 'Cliente no encontrado. Verifica tus datos.' }; }
function buscarOcrearTarjeta(nombre, telefono, fechaNacimiento) { const data = clientesSheet.getDataRange().getValues(); for (let i = 1; i < data.length; i++) { const sheetDate = data[i][4] ? new Date(data[i][4]).toISOString().split('T')[0] : ''; if (String(data[i][3]) == String(telefono) && sheetDate == String(fechaNacimiento)) { return { status: 'success', message: 'Cliente encontrado.', data: { folio: data[i][0], nombre: data[i][1], visitas: data[i][2] } }; } } let folio; do { folio = `F-${nombre.substring(0,2).toUpperCase()}${telefono.slice(-2)}${fechaNacimiento.substring(8,10)}${Math.random().toString(36).substring(2,5).toUpperCase()}`; } while (data.some(row => row[0] === folio)); clientesSheet.appendRow([folio, nombre, 0, telefono, new Date(fechaNacimiento)]); return { status: 'success', message: 'Cliente creado con éxito.', data: { folio, nombre, visitas: 0 } }; }
function registrarVisita(folio) { const range = clientesSheet.getDataRange(); const values = range.getValues(); for (let i = 1; i < values.length; i++) { if (values[i][0] === folio) { const newVisits = Number(values[i][2]) + 1; clientesSheet.getRange(i + 1, 3).setValue(newVisits); return { status: 'success', newVisits }; } } return { status: 'error', message: 'Folio no encontrado.' }; }
function canjearRecompensa(folio, nombreCliente, recompensa, costo) { const range = clientesSheet.getDataRange(); const values = range.getValues(); for (let i = 1; i < values.length; i++) { if (values[i][0] === folio) { const currentVisits = Number(values[i][2]); if (currentVisits >= Number(costo)) { const newVisits = currentVisits - Number(costo); clientesSheet.getRange(i + 1, 3).setValue(newVisits); transaccionesSheet.appendRow([new Date(), folio, nombreCliente, recompensa, costo]); return { status: 'success', newVisits }; } else { return { status: 'error', message: 'Visitas insuficientes.' }; } } } return { status: 'error', message: 'Folio no encontrado.' }; }
function listarTarjetas() { const data = clientesSheet.getDataRange().getValues(); data.shift(); const clients = data.map(row => ({ folio: row[0], nombre: row[1], visitas: row[2], telefono: row[3], fechaNacimiento: row[4] ? new Date(row[4]).toISOString().split('T')[0] : '' })); return { status: 'success', data: clients }; }
function obtenerConfiguracion() { const data = configSheet.getDataRange().getValues(); const config = { rules: {}, rewards: [] }; data.forEach((row, index) => { if (index === 0) return; const [tipo, clave, valor] = row; if (tipo === 'Regla') config.rules[clave] = valor; if (tipo === 'Recompensa') config.rewards.push({ clave, valor }); }); return { status: 'success', data: config }; }
function guardarConfiguracion(config) { const lastRow = configSheet.getLastRow(); if (lastRow > 1) { configSheet.getRange('A2:C' + lastRow).clearContent(); } const newRows = []; if (config.passwordHash) { newRows.push(['Credencial', 'AdminPasswordHash', config.passwordHash]); } for (const key in config.rules) { newRows.push(['Regla', key, config.rules[key]]); } config.rewards.forEach(r => { newRows.push(['Recompensa', r.clave, r.valor]); }); if (newRows.length > 0) { configSheet.getRange(2, 1, newRows.length, 3).setValues(newRows); } return { status: 'success', message: 'Configuración guardada.' }; }
function enviarMensaje(remitente, mensaje) { mensajesSheet.appendRow([new Date(), remitente, mensaje]); return { status: 'success' }; }
function obtenerMensajes() { const data = mensajesSheet.getDataRange().getValues(); const messages = data.map(row => ({ timestamp: row[0], sender: row[1], message: row[2] })); return { status: 'success', data: messages.slice(-50).reverse() }; }
